package custom

import (
	"context"
	"fmt"
	"io"
	"taskd/dao"
	"taskd/internal/task"
	"taskd/internal/utils"

	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// Task struct for CRD types (kubeflow XXJobs)
type Crd struct {
	replicas          int                         // Replica count
	getLabel          func(string) v1.ListOptions // Label selector for Pods
	ctx               context.Context             // Runtime context
	task.TaskInstance                             // Instance (base class)
}

/**
 *	Initialize CRD type task instance
 *	@param td *task.TemplateRec Task object
 *  @param tr *task.TaskRec Task instance data
 */
func NewCrd(td *dao.TemplateRec, tr *dao.TaskRec) (task.TaskJob, error) {
	crd := &Crd{}

	if err := crd.Init(td, tr); err != nil {
		return nil, fmt.Errorf("error in NewCrd init: %v", err)
	}
	extra, err := task.ParseArgs(tr.Extra)
	if err != nil {
		return nil, fmt.Errorf("error in NewCrd parse task_obj.extra: %v", err)
	}
	crd.replicas = task.GetArgInt(extra, "masterNum", 1) + task.GetArgInt(extra, "workerNum", 0)
	crd.getLabel = utils.GetTaskLabelSelector
	crd.ctx = context.Background()

	return crd, nil
}

/**
 *	Get client to communicate with K8S
 */
func (s *Crd) getClientSet() *kubernetes.Clientset {
	clientset, ok := s.GetPool().Extension.(*kubernetes.Clientset)
	if !ok {
		return nil
	}
	return clientset
}

/**
 * Start task
 */
func (s *Crd) Start() error {
	return utils.Apply(s.Namespace, s.Template, s.YamlContent)
}

/**
 * Get list of Pods started by the task
 */
func (s *Crd) Get() *corev1.PodList {
	podList, err := s.getClientSet().CoreV1().Pods(s.Namespace).
		List(s.ctx, s.getLabel(s.UUID))
	if err != nil {
		utils.Errorf("Task [%s] failed to obtain the list of started Pods: %v", s.Title(), err)
	}
	return podList
}

/**
 * Get list of Job events
 */
func (s *Crd) getJobEvents() (string, error) {
	fieldSelector := fmt.Sprintf("involvedObject.namespace=%s,involvedObject.name=%s,involvedObject.kind=%s",
		s.Namespace, s.Name, "PyTorchJob")
	events, err := s.getClientSet().CoreV1().Events(s.Namespace).
		List(s.ctx, v1.ListOptions{
			FieldSelector: fieldSelector,
		})
	if err != nil {
		return "get events failed", fmt.Errorf("无法读取事件: %v", err)
	}

	var result string
	for _, event := range events.Items {
		result += fmt.Sprintf("Reason: %s, Message: %s\n", event.Reason, event.Message)
	}
	return result, nil
}

/**
 * Get task status
 */
func (s *Crd) FetchStatus() task.TaskStatus {
	status, err := s.getJobStatus()
	if err != nil {
		utils.Errorf("Failed to obtain the status of task [%s]: %v", s.Title(), err)
		return task.TaskStatusInit //if any issue occurs, return an earlier state that will be ignored by the status handler
	}

	taskStatus, ok := jobStatus2TaskStatus[status]
	if !ok {
		return task.TaskStatusInit
	}
	return taskStatus
}

/**
 * Get latest status from XXJob's status.conditions
 */
func (s *Crd) getJobStatus() (string, error) {
	return utils.GetPytorchJobStatus(s.Namespace, "pytorchjob", s.Name)
}

/**
 * Stream logs output
 */
func (s *Crd) FollowLogs(podName string, timestamp bool, tail int64) (io.ReadCloser, error) {
	if podName == "" {
		for _, pod := range s.Get().Items {
			podName = pod.GetName()
		}
		if podName == "" {
			return nil, fmt.Errorf("no any pod")
		}
	}
	req := s.getClientSet().CoreV1().Pods(s.Namespace).
		GetLogs(podName, &corev1.PodLogOptions{
			Follow:     true,
			Timestamps: timestamp,
			TailLines:  &tail,
		})
	return req.Stream(context.Background())
}

/**
 * Get logs generated by POD with name podName
 */
func (s *Crd) podLogs(podName string, tail int64) (task.EntityLogs, error) {
	var result string
	if podName == "" {
		podName = "merged"
		podLogs, err := utils.GetTaskLogs(s.Namespace, s.UUID, uint(tail))
		if err != nil {
			return task.EntityLogs{}, fmt.Errorf("读取Pod(%s)的Loki日志失败: %v", podName, err)
		}

		for _, l := range podLogs {
			result = l.Line + "\n" + result
		}
	} else {
		podLog := s.getClientSet().CoreV1().Pods(s.Namespace).
			GetLogs(podName, &corev1.PodLogOptions{
				TailLines: &tail,
			}).Do(s.ctx)
		if podLog.Error() != nil {
			return task.EntityLogs{}, fmt.Errorf("无法读取Pod(%s)日志: %v", podName, podLog.Error())
		}
		result_byte, err := podLog.Raw()
		if err != nil {
			return task.EntityLogs{}, fmt.Errorf("读取Pod(%s)日志失败: %v", podName, err)
		}
		result = string(result_byte)
	}

	return task.EntityLogs{
		Logs:      result,
		Entity:    podName,
		Completed: s.Phase() == task.PhaseFinished,
	}, nil
}

/**
 * Get logs from Pods started by the task
 */
func (s *Crd) Logs(podName string, tail int64) ([]task.EntityLogs, error) {
	var results []task.EntityLogs
	// When podName is not empty, directly get logs for podName
	if podName != "" {
		logs, err := s.podLogs(podName, tail)
		if err != nil {
			return results, err
		}
		results = append(results, logs)
		return results, nil
	}

	// When podName is empty, get all pods
	items := s.Get().Items
	// If pod list is empty, get logs via loki
	if len(items) == 0 {
		logs, err := s.podLogs("", tail)
		if err != nil {
			return results, err
		}
		results = append(results, logs)
		return results, nil
	}

	// If pod list is not empty, get logs for all pods
	for _, pod := range items {
		logs, err := s.podLogs(pod.GetName(), tail)
		if err != nil {
			utils.Errorf("Crd [%s] pod [%s] error: %v", s.Title(), pod.Name, err)
			continue
		}
		results = append(results, logs)
	}

	// Get job events list
	eventLog, err := s.getJobEvents()
	if err != nil {
		utils.Errorf("Crd [%s] %v", s.Title(), err)
	}
	results = append(results, task.EntityLogs{
		Entity:    fmt.Sprintf("PyTorchJob %s/%s events", s.Namespace, s.Name),
		Logs:      eventLog,
		Completed: task.TaskStatus(s.Instance().Status).IsFinished(),
	})
	return results, nil
}

/**
 * Stop task
 */
func (s *Crd) Stop() error {
	// Call sync kubectl delete command
	utils.K8sDelete(s.YamlContent, true)
	return nil
}

func (s *Crd) CustomMetrics() *task.Metric {
	return nil
}

/**
 * JOB type (different types imply different underlying implementations)
 */
func (s *Crd) Engine() task.TaskEngineKind {
	return task.CrdEngine
}
